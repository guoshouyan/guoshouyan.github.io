---
layout: post
title: Algorithm
---

## 动态规划，贪心算法
最优子结构：问题的最优解也是子问题最优解
重叠子结构：子问题重复计算

1. 从一堆选择中选择最优解，选择顺序不一定
背包问题：建立一个数组，横轴是有小到大的背包，纵轴是每个物品
* 01背包问题
物品只能选着拿与不拿，每个只有一个
$M[i][j]=max(M[i-1][j-weight[i]]+value[i], M[i-1][j])$
注意此时新的值都是来自于前一行，不能与当前行的值累加，不然就等于拿了多个同样的物品

* 完全背包问题
每个物品可以拿多次，数量无限
此时可以与当前行累加，用一维数组解决
$M[j]=max(M[j-weight[i]]+value[i], M[j])$

* 多重背包问题
每个物品可以拿多次，数量有限
需要多一个数组，初始化为该物品的数量最大值，每更新原数组一格，就更新该格数量

2. 可以跳过某些单词的字符串匹配：
* LCS 最长公共子序列
动态规划的矩阵有三个方向，向上，向右不能加一，斜向上相同+1
向上向右是为了能跳过某些单词，如果题目规定不能跳过，那直接用字符串匹配方法

---

## 链表
1. 快慢指针
* 有环链表

---

## 栈，队列
1. Catalan数
$$h(n)=h(0)*h(n-1)+h(1)*h(n-2)+...+h(n-1)*h(0)$$
$$C_{n}=\frac{1}{n+1}\binom{2n}{n}=\frac{(2n)!}{(2n-n)!n!}$$
* 出栈顺序

---

## 树
1. 二叉树
* 储存结构
* 遍历
* 深度
2. 哈夫曼编码
3. 并查集

---

## 图
1. 图储存
2. 图遍历
* 深度优先
* 广度优先
3. 最小生成树
4. 最短路径
5. 拓扑排序

---

## 排序
1. 快速排序
2. 归并排序
3. 堆排序

---

## 查找
1. 二分查找
2. 键树
3. 后缀树，后缀数组
4. 哈希表
5. 一致性哈希
6. 海量数据
* bit-map
* bloom filter





