[{"title":"云计算：Data Center Networking","date":"2017-05-08T18:31:07.000Z","path":"2017/05/08/Networking/","text":"数据中心的网络面临两个问题：一个是有很多虚拟机导致有很多ip地址，scale困难。一个是vm的migration希望能做到ip不变。 先复习一下network知识网络七层模型：其中layer2是mac地址，layer3是IP地址。bridge：网络中每个host通过bridge相连，组成LAN，它知道每一个port对应有说明MAC地址。有学习功能的bridge还能学习更新每个端口的Mac地址。ARP：把ip地址转到mac地址，host缓存ARP信息能使发送更快。 VLANs：将一个LAN分区，组成一个个subnet。它只改变逻辑结构，没改变物理结构。同一个vLAN有个公有IP地址，内部每个host又有私有ip地址。VLAN通过switch交换机实现。第一个交换机插入VLAN的ID，最后一个交换机删去。 Router：将不同结构的LAN连接在一起IP地址查找，Tunneling：在桢前加上ip地址，强迫该桢走某个路径。通过Tunneling的方法来实现VPN。Circuit Switching VS Packet Switching：这是两种不同的传输方式，第一种有个固定的特定的路径用来传输，第二种在传输过程中能选择不同路径。Virtual Circuit Forwarding：用vc id而不是用ip地址MPLS：Multi-Protocol Label Switching。通过Label Switched Path将ip地址映射成一个标签，为了更快的交换传输。 数据中心网络要求VM migration ip不变，交换机能自动更新配置，故障恢复要快，所有数据通路能被所有节点共享。LANs和VLANs要支持broadcast，这样交换机的配置才能自动更新。用spanning tree来解决forwarding loops的问题。 软件定义网络SDN就是路由器和交换机里面的转发表交由一个中央管理器生成。将控制功能与转发功能分离。","tags":[{"name":"学技术","slug":"学技术","permalink":"http://yoursite.com/tags/学技术/"}]},{"title":"云计算：运行于spot price","date":"2017-05-08T18:29:37.000Z","path":"2017/05/08/云计算：运行于spot price/","text":"aws有一个spot price的机制。如果你出价比当前市场价要高，机器就是你的。如果低，aws会把机子收回。 论文：Proteus: agile ML elasticity through tiered reliability in dynamic resource markets 用了上面这个机制来为machine learning省钱。这种高端省钱低方法我十分欣赏 :) 普通ml就是输入数据，迭代计算，输出模型。它多出一个parameter server，放在on demand的机器上。spot price的机器就用来跑程序，计算结果放在parameter server上。这样就保证结果不会丢失。 AgileML：AgileML 是这个系统的计算部分，它首先将资源分成reliable和transient两种。同时包括三个阶段：1，全部的parameter server都放在reliable的机器上2，这时候ps(parameter server)会成为瓶颈，因此将ps分成两部分，activePs放在transient的机器上，backupPS放在reliable低机器上。3，所有的worker都放在transient的机器上。这三个阶段是要根据当前机器的数量来不断转化的。 BidBrain：它就是系统中负责向亚马逊申请资源的部分了。它有一条公式计算应该出价多少的。1，先需要跟踪aws的历史数据，计算出出价增加多少，机器不会被收回的时间延长多少。2，从AgileML得到这个任务要开始多久才有产出。3，scale和evict的overhead等。","tags":[{"name":"学技术","slug":"学技术","permalink":"http://yoursite.com/tags/学技术/"}]},{"title":"云计算：Geo-replication","date":"2017-05-08T18:27:24.000Z","path":"2017/05/08/云计算：Geo-replication/","text":"异地备份，Geo-replication，一是为了容灾，二是为了访问低延迟。但如果要保持各个备份的一致性就会有比较大的延迟。这就联系到传说中的CAP理论。 但是现在有人提出了ALPS理论：Availability， Low Latency， Partition Tolerance， Scalability每一个备份都能独立作为data center，更新在后台同步，实现eventual consistency.当时在下面这篇论文里提出了一种更加高级的consistency - casual consistency with convergent conflict handing. STRONGER CONSISTENCY AND SEMANTICS FOR LOW-LATENCY GEO-REPLICATED STORAGE by WYATT ANDREW LLOYD Casual Consistency是指如果存在因果关系的事件发生顺序在每个备份里都是一样的，如果没有因果关系，就退化成eventually consistency。 如何定义a和b之间存在casual的关系：1，a和b是同一个线程发生的事件2，b要返回a写操作后的值3，a与c是casual，c与b是casual，根据传递性得到a与b是casual Conflict HandlingCasual Consistency仍然有缺陷，它只规定了两个有因果关系的事件发生顺序在每个备份里是一样的，当时没有规定两个同时发生的事件。如果两个人同时往同一个地方写，就会有conflict。解决的策略要不是最后一个写的覆盖掉全部，要不用更复杂的冲突解决方法。另一种方法是加上version，比如用逻辑时钟。每个备份都记录log，并相互交换，最后达成一致。 无论是Casual Consistency还是Conflict Handling，都要依赖机器之间的沟通甚至等待。但是依靠机器之间通信达成一致，都会有一个缺陷，叫做slowdown cascades，一台慢的机器会拖累到其他机器。于是有人提出了个叫OCCULT的系统解决这个问题。 推荐看视频，画一下重点：这个系统多了一个叫observable casual consistency。就是只要client看到的东西是casual consistency就行了，内部的我不管。 它使用timestamp的方法，server有timestamp，client也有。每次读写都会更新取最大。比如存在a-&gt;b的关系，timestamp是（8，5），分别代表a和b。假如在一台机的timestamp是(8,5),在另一台机的timestamp是（7，5），说明b的更新传到了，当时a还没。此时client的timestamp是(0,0)，比它们都小，因此他可以读a或b。假如client读了b，他的timestamp就同步成(8,5)，那他就不能再读那台timestamp是(7,5)的机子上面的a。","tags":[{"name":"学技术","slug":"学技术","permalink":"http://yoursite.com/tags/学技术/"}]},{"title":"云计算：Tail Latency","date":"2017-05-08T18:25:53.000Z","path":"2017/05/08/云计算：Tail Latency/","text":"尾延迟：有一小部分的请求比平均水平慢，结果成了瓶颈，拖累了整体请求的响应时间。 首先程序运行时间是会变化的：1，有时候会被运行在同一个infrastructure的其它程序影响。2，Background/maintenance activities：垃圾回收，log压缩3，硬件影响4，cache，queueing等发生等场景往往是一个有很大fan-out的程序。就是说一个程序等待很多子程序返回后才返回。 方案1, 减少服务时间等变化设定优先级，优先处理重要任务让不同机器的maintenance stuff同时运行，减少影响的时间选择集群比较有空的时间来运行background stuff 单个请求优化2, “hedged” requests同时发送两个请求到不同机器，取第一个返回的结果如果觉得traffic太大了，先推测出99%的返回时间。如果第一个请求比99%都慢，再发第二个。 3, “tied” requests这是用来解决queueing wait time的。同时向多台机发送请求，每台机都知道有那些其它的机器。当其中一台机开始运行或结束，它把其它机器的这个job都cancel掉。 多个请求优化workload的不平衡也会导致tail latency。4, Micro-partitions更多的partition，通常比机器的数量更多，更容易做负载均衡。 5, Selective replicationMicro-partitions的升级版，检测出导致负载不均衡的文件，然后多做复制备份到不同分区。 6, Latency-induced probation中间层不断检测各个machine的状况，剔除较差的，知道他们情况变好了才重新加进来。 7, 比较特殊的方法就是有些app由于情况特殊，其实不用返回全部信息。比如information-retrieval (IR)只需要在规定时间内返回信息。有时候某些request就是肯定会产生failure。 参考文献：The Tail at Scale by JeffRey Dean and Luiz André BaRRoSo","tags":[{"name":"学技术","slug":"学技术","permalink":"http://yoursite.com/tags/学技术/"}]},{"title":"云计算：安全类型","date":"2017-05-08T18:24:14.000Z","path":"2017/05/08/云计算：安全类型/","text":"云计算的安全威胁主要来自两个方面，一个是来自于云计算提供商（CSP），另一个来自于CSP的其它使用者。 攻击模式1， 来自于CSP的对存储数据的检测与改变：Storage manipulation，Storage monitoring使用有缺陷的镜像与虚拟机：VM image sharing， Compromised hypervisor没有依照可以提供服务，比如没有做足够的备份：Storage dishonesty，Location dishonesty，SLA dishonesty 2， 自于CSP的其它使用者攻击者试图与受害者用同一台机，通过cache等方法攻击。Cache-based leakage channels， General leakage channels 防御方式1， 系统层面提供好的虚拟机，防火墙： Hypervisor，Firewalls对数据中心进行保障，限制人员进入：Data center operations定制的VM：Dedicated VMsCSP自己的业务与客户的业务分离：Corporate segregation 2，加密传输过程加密(Cryptography while in transit) - SSL在云端储存时加密(Cryptography at rest) 3， 权限控制验证(Authentication) - single sign on：首先登陆拿到验证文件，然后每次都使用那个文件使用服务。用户创建与访问控制(User creation and access contro)：跟文件系统差不多，加上时间和ip地址控制。 4, CSPCSP自己受到攻击不会影响客户(CSP Security)CSP contract：用户选择VM的地理位置，SLA协议，计费。 更广泛的攻击1, cache channel：通过flush and load推算出用户在用cache都哪一部分。2, storage channel：就算读取不到加密的信息，也能读取access pattern。3, covert channel：入侵vm使得信息泄漏4, image sharing：镜像共享5, Leak prevention: 不把敏感信息传输给csp，在私有云运行。6，Integrity, Availability Issues7，Contractual Issues 同态加密将信息运算后加密的结果，跟各自加密再运算的加过是一样的。这样在云端进行运算的时候就不用先解密了，CSP也不知道你写了什么。问题是速度慢。 CryptDB：加密的数据库。直接对加密信息进行运算，只支持有限类型的操作。 安全硬件Intel SGX，创造一个叫enclave都环境，再里面执行的代码和数据都是安全的，其他任何权限的进程都不能访问。","tags":[{"name":"学技术","slug":"学技术","permalink":"http://yoursite.com/tags/学技术/"}]},{"title":"Docker容器简单使用","date":"2017-04-17T23:03:25.000Z","path":"2017/04/17/Docker容器简单使用/","text":"docker三个重要概念：镜像，容器，仓库。 安装mac由于没有Linux环境，需要先装docker-machine。docker-machine能帮你创建不同的docker engine(hypervisor)。 docker 命令是在docker engine 上创建不同的容器。 创建docker engine12345678创建docker engine：docker-machine create --driver virtualbox --virtualbox-cpu-count 2 --virtualbox-memory 2048 newEngine得到不同engineIP地址：docker-machine ip newEngine 切换到不同的docker engine上：eval $(docker-machine env newEngine) 使用容器容器相当于由镜像创建的动态虚拟机。1.创建一个容器：1docker run -d -p 80:80 --name webserver nginx 需要注意的是如果不是在后台运行，容器执行完程序后会自动停止webserver就是容器的名字nginx就是使用镜像的名字其它选项有：12345-t 选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上-i 让容器的标准输入保持打开前两个选项能直接跟容器bash沟通-d 后台运行-p 绑定端口 2.改变容器状态：12docker stop webserverdocker rm webserver 3.检查容器状态12345docker ps 正在运行的容器，-a 包括已经停止的containerdocker top 容器里面正在运行的程序docker logs id 查看输出的logdocker attach id 连接容器，ctrl-p, ctrl-q退出docker exec -i -t id bash 另一种进入容器方法 4.连接容器1docker run -d -P --name web --link db:db training/webapp –link 参数的格式为 –link name:alias，其中 name 是要链接的容器的名称，是这个连接的别名 5.添加数据卷123docker volume ls 查看数据卷docker volume rm 删除数据卷docker run -it -d -v /local/path:/opt/webapp ubuntu:14.04 /bin/bash 数据卷不会随着容器的删除而删除，除非加上-rm。-v /local/path:/opt/webapp 是连接一个数据卷到容器里，：号前面是本地的文件夹，后面是在容器里显示的路径","tags":[{"name":"学技术","slug":"学技术","permalink":"http://yoursite.com/tags/学技术/"}]},{"title":"云计算：分布式监控与追踪","date":"2017-04-05T18:15:25.000Z","path":"2017/04/05/云计算：分布式监控与追踪/","text":"本系列将简谈云计算都各方面技术，本次介绍分布式监控与追踪 分布式监控与追踪监控与追踪分为三种，1， 第一种是performance counter， 记录CPU，disk都各种数据。比如aws的cloud watch，Ganglia。在Ganglia都结构图如下：比较特别都是同一个cluster里的数据会向其它节点广播，要查询数据都时候只需要问其中一个节点要就好了。这样减少了节点加入或离开集群都复杂度，同时保证的数据备份，但是增加了数据都传输量。 2，另一种是logging，记录各种发生都时间。 3，最后一种是基于workflow都end-to-end tracing。它虽然用logging的方式，但是纪录的是每个事件发生都所有步骤，经过了各种子系统。其中代表有cmu的workflow-centric 和Google的Dapper。cmu的系统结构图如下：其通过在不同系统设置trace point，跟踪每一个请求到达的trace point来跟踪每一个请求，然后放到trace storage里面。 Google的Dapper：Dapper里子系统都是通过RPC调用，因此Dapper设计出一个树状结构的trace。每一个RPC带有父系统的trace id和自己的span id。这样每个系统都能各自trace自己的事件。","tags":[{"name":"学技术","slug":"学技术","permalink":"http://yoursite.com/tags/学技术/"}]},{"title":"玩玩Reddit","date":"2017-04-04T21:13:02.000Z","path":"2017/04/04/玩玩Reddit/","text":"今天来尝试玩玩国外的“百度贴吧”–Reddit","tags":[{"name":"玩产品","slug":"玩产品","permalink":"http://yoursite.com/tags/玩产品/"}]},{"title":"Hello World","date":"2017-03-26T22:00:09.000Z","path":"2017/03/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]